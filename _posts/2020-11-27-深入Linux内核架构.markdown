---
layout: article
title: 《深入linux内核架构》笔记
author: site.author
tags: note
key: note-2020-11-27-1
pageview: true
comment: true
show_edit_on_github: false
show_subscribe: false

---



​    《深入linux内核架构》的笔记，长期更新。

<!--more-->

#  第一章

##### 1.1  内核的任务

1. 内核是硬件与软件之间的中间层
2. 当程序并发进行时，内核要进行资源管理
3. 提供了一组面向系统的命令

##### 1.2 实现的策略

+ 什么是微内核？

  只有最基本的功能(任务调度等)由中央内核实现，其余功能(文件系统、内存管理等)由独立进程实现。它们通过通信接口与内核通信。

+ 什么是宏内核？

  与微内核相反，内核的全部功能和所有子系统都打包到一个文件中，内核中的函数可以访问内核中的其它部分。Linux采用宏内核，同时引入了一个重要的革新：模块。模块可以动态的添加功能，弥补了宏内核的缺陷。

+ 宏内核的性能强于微内核

##### 1.3 内核的组成部分

1. 进程、进程切换、调度、命名空间

   + 进程：每个进程都可以在CPU的虚拟内存中分配地址空间，完全独立。每个进程都会认为自己是系统中唯一的进程（在地址空间中更有体现），它们可以通过内核机制通信。Linux对进程采用了层次结构，每个进程都依赖一个父进程。在终端中使用`pstree`命令可以打印出进程树，init是内核启动的第一个进程，作为进程树的根。创建进程的两种机制：

     >1.  fork 子进程复制父进程，在只读的情况下父进程和子进程可以共用同一页存页
     >2.  exec 新程序加载到当前进程的内存中并执行，旧程序的内存页将被刷出，内容被替换成新的数据。

   + 线程：本质上讲一个进程可能由若干线程组成。
   
   + 调度：Linux是多任务系统，支持（看上去）并发执行。系统中真正在运行的进程最多不超过CPU的数量，这就需要调度器去切换进程，造成进程并发执行的假象。Linux采用完全公平的调度算法(CFS)，
   
   + 命名空间:系统中每一个进程都有一个标识符(ID)，可以使用ID来访问进程。启用命名空间后，全局资源具有不同得分组，每个命名空间可以包含一个特定得PID集合。

2. 地址空间与特权级别

    - 由于内存区域是通过指针寻址的，因此CPU的字长决定了所能管理的地址空间最大长度。
    - 地址空间的最大长度与实际可用的物理内存数量无关，因此也被称为虚拟地址空间。从进程角度来看，每一个进程都是系统中唯一的进程。
    - Linux将虚拟地址空间划分为2部分，内核空间和用户空间。从0到TASK_SIZE的地址空间为用户空间，TASK_SIZE到最大地址为内核空间。TASK_SIZE是一个特定于计算机体系结构的常数，在IA-32体系中，TASK_SIZE在3GiB处划分。这种划分与可用的内存数量无关，每一个用户进程都会认为自己有3GiB的内存。
    - 在64位的计算机中，由于有64位的寻址长度，因此管理着巨大的理论虚拟空间，实际上寻址的位数一般小于64位，从而给CPU减轻工作量。即使小于64位的寻址位数，但也有着很大的虚拟空间地址。无论无何，该值任然会大于计算机上实际可能的内存数量。
    - 地址空间有两种空间，所以进程也有两种状态，核心态和用户态。在用户态禁止访问内核空间，用户进程不能操作和读取内核空间的数据，也无法执行内核空间中的代码。这种机制可以防止进程无意间修改彼此的数据而造成互相干扰。  
    - 从用户态到核心态有两种方法：
      > 1. 用户进程向内核提交申请想要执行的操作，内核确认后代表执行用户进程，然后将执行结果返回到用户进程
      > 2. 由异步硬件激活，然后在中断上下文运行。由于中断是随时发生的，发生时不确定是哪一个进程处于活动态，因此内核无权访问当前的用户进程，只能在中断上下文中运行。

3. 虚拟与 物理地址空间
    -  虚拟地址空间被内核划分为很多等长的部分，这些部分称之为**页**。物理内存页划分为同样大小的的部分，经常被成为**页帧**。
    -  同一进程的不同页或者不同进程的页可以映射到相同或不同的物理内存页帧上。
    - **页表**：将虚拟内存空间映射到物理空间的**数据结构**
    - 页表解决的问题是如何将虚拟地址映射到物理地址。如果将虚拟地址空间的所有页表分配一个数组，将页帧的地址填到对应的数组项中，就可以很好的解决，但这样有个问题，此数组很大，如果虚拟地址由4GiB，那数组有100万项(一页4KiB)，并且每个进程都要分配一个这样的数组，显然是不现实的，况且进程也没有关联到那么多页帧。
    - 采用多级页表和划分为多个部分的虚拟地址可以很好的解决虚拟地址映射到物理地址的问题。Linux采用4级页表，这样也会有一个缺点，每次访问一个内存需要逐级访问页表才能将虚拟地址转换为物理地址。CPU也有办法加速该过程：
       > 1. MMU(Memory Management Unit，内存管理单元)，该单元优化了内存的访问操作。
       >
       > 2. TLB(Translation Look aside Buffer，地址转换后备缓冲器)，保存频繁访问的转换地址。 

4. 内存映射		

   -  	     内存映射是一种重要的抽象手段，在内核中大量使用。
   -  	     例如，将文件映射到内存中，处理只需要读取相应的内存即可访问文件内容，向内存中写入的时候，内核将保证任何修改都会自动同步到文件中
   -  	     例如，内核实现设备驱动程序时直接使用了内存映射。外设的输入/输出可以映射到虚拟地址空间的区域中，对相关内存域的读写会有系统重定向到设备，这样大大简化了驱动程序的的实现。

5. 物理内存的分配
   - 内核负责分配完整的页帧给进程，同时记录页帧的分配状态。将内存划分为更小的部分的工作，则委托给用户空间的标准库。
   - 内核中有很多时候需要分配连续的页帧，内核采用了一种古老的技术：伙伴系统。
   - 简单解释伙伴系统：如果内核需要8个页帧的连续的存储空间，那么内核将会寻找16个页帧的连续存储空间分成两块。空出来的8页帧的空间由内核同一管理，内核会对所有大小相同的伙伴，都放在同一个列表中。内存释放的时候刚好是分配的逆过程，

6. slab缓存器
   - 如果内核需要比页帧小的多的内存，而且无法使用标准库分配内存，那就需要在伙伴系统上定义一个额外的内存管理层。
   - slab缓存自动维护与伙伴系统的交互，在缓存用尽时会请求新的页帧。

7. 页面交换和页面回收
   
   - 可以将不经常使用的页写入磁盘，进程需要时，内核在写入到内存。页的换入换出对进程不可见。
   
8. 计时

    + 使用全局变量jiffies_64和jiffies。递增的频率取决于内核，通常在100～1000Hz。

9. 系统调用

    + 用户进程和内核交互的经典办法，按分类有：

      >进程管理
      >
      >信号
      >
      >文件
      >
      >目录和文件系统
      >
      >保护机制
      >
      >定时器函数

10. 设备驱动程序和块设备和字符设备

    + 万物皆文件(everything is a file)
    + 设备驱动程序的任务在于支持应用程序通过文件与设备通信，在`/dev`目录下。
    + 那么这些设备文件有两类：字符设备和块设备

11. 网络

    + 网卡可以通过设备驱动程序控制，但在内核中属于特殊情况，因为网卡不能使用设备文件访问
    + linux使用了源于BSD的套接字抽象了网卡

12. 文件系统

    + linux支持很多文件系统

      > Ext2、Ext3、XFS、VFAT等

    + linux提供了一个VFS虚拟文件系统，将各种底层文件系统的具体特征与应用层隔开，使得用户调用统一。

13. 模块和热拔插

    + 模块用于在运行时动态地向内核添加功能，比如：设备驱动程序、文件系统、网络协议；也可动态卸载模块。
    + 模块的功能消除了与微内核相比的一个重要的不利之处
    + 在系统检测到新设备时，加载对应的模块，可以将必要的驱动程序加载到内核中，实现热拔插。

14. 页缓存

    + 将低速的块设备的数据暂时保存到内存中，即使数据在当时不需要，但能提高下次的访问速度。

    

